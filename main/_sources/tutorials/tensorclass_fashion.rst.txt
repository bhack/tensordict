
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/tensorclass_fashion.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_tensorclass_fashion.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_tensorclass_fashion.py:


Using tensorclasses for datasets
================================

.. GENERATED FROM PYTHON SOURCE LINES 8-14

In this tutorial we demonstrate how tensorclasses can be used to
efficiently and transparently load and manage data inside a training
pipeline. The tutorial is based heavily on the `PyTorch Quickstart
Tutorial <https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html>`__,
but modified to demonstrate use of tensorclass. See the related tutorial using
``TensorDict``.

.. GENERATED FROM PYTHON SOURCE LINES 14-28

.. code-block:: Python



    import torch
    import torch.nn as nn

    from tensordict import MemoryMappedTensor, tensorclass
    from torch.utils.data import DataLoader
    from torchvision import datasets
    from torchvision.transforms import ToTensor

    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"Using device: {device}")






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Using device: cpu




.. GENERATED FROM PYTHON SOURCE LINES 29-33

The ``torchvision.datasets`` module contains a number of convenient pre-prepared
datasets. In this tutorial we'll use the relatively simple FashionMNIST dataset. Each
image is an item of clothing, the objective is to classify the type of clothing in
the image (e.g. "Bag", "Sneaker" etc.).

.. GENERATED FROM PYTHON SOURCE LINES 33-47

.. code-block:: Python


    training_data = datasets.FashionMNIST(
        root="data",
        train=True,
        download=True,
        transform=ToTensor(),
    )
    test_data = datasets.FashionMNIST(
        root="data",
        train=False,
        download=True,
        transform=ToTensor(),
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-images-idx3-ubyte.gz to data/FashionMNIST/raw/train-images-idx3-ubyte.gz
      0%|          | 0/26421880 [00:00<?, ?it/s]      0%|          | 65536/26421880 [00:00<01:12, 363461.94it/s]      1%|          | 229376/26421880 [00:00<00:38, 684379.24it/s]      4%|▎         | 950272/26421880 [00:00<00:11, 2194877.35it/s]     15%|█▍        | 3833856/26421880 [00:00<00:02, 7630733.14it/s]     38%|███▊      | 10059776/26421880 [00:00<00:00, 17286900.68it/s]     61%|██████    | 16154624/26421880 [00:01<00:00, 22874706.44it/s]     84%|████████▍ | 22282240/26421880 [00:01<00:00, 26342243.35it/s]    100%|██████████| 26421880/26421880 [00:01<00:00, 19400092.18it/s]
    Extracting data/FashionMNIST/raw/train-images-idx3-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw/train-labels-idx1-ubyte.gz
      0%|          | 0/29515 [00:00<?, ?it/s]    100%|██████████| 29515/29515 [00:00<00:00, 327420.87it/s]
    Extracting data/FashionMNIST/raw/train-labels-idx1-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz
      0%|          | 0/4422102 [00:00<?, ?it/s]      1%|▏         | 65536/4422102 [00:00<00:11, 364005.34it/s]      3%|▎         | 131072/4422102 [00:00<00:11, 363269.61it/s]      4%|▍         | 196608/4422102 [00:00<00:11, 363129.67it/s]      6%|▌         | 262144/4422102 [00:00<00:11, 363002.83it/s]      7%|▋         | 327680/4422102 [00:00<00:11, 363108.92it/s]     10%|▉         | 425984/4422102 [00:01<00:09, 424596.76it/s]     12%|█▏        | 524288/4422102 [00:01<00:08, 463833.84it/s]     14%|█▍        | 622592/4422102 [00:01<00:07, 489626.57it/s]     17%|█▋        | 753664/4422102 [00:01<00:06, 563026.01it/s]     20%|██        | 884736/4422102 [00:01<00:05, 613158.77it/s]     23%|██▎       | 1015808/4422102 [00:01<00:05, 648512.03it/s]     27%|██▋       | 1179648/4422102 [00:02<00:04, 726785.81it/s]     31%|███       | 1376256/4422102 [00:02<00:03, 834273.69it/s]     36%|███▌      | 1572864/4422102 [00:02<00:03, 910327.57it/s]     40%|████      | 1769472/4422102 [00:02<00:02, 965157.32it/s]     45%|████▌     | 1998848/4422102 [00:02<00:02, 1060835.89it/s]     51%|█████     | 2260992/4422102 [00:03<00:01, 1177446.25it/s]     58%|█████▊    | 2555904/4422102 [00:03<00:01, 1309197.51it/s]     65%|██████▌   | 2883584/4422102 [00:03<00:01, 1457227.28it/s]     73%|███████▎  | 3211264/4422102 [00:03<00:00, 1574367.99it/s]     82%|████████▏ | 3604480/4422102 [00:03<00:00, 1747875.79it/s]     91%|█████████ | 4030464/4422102 [00:03<00:00, 1931243.65it/s]    100%|██████████| 4422102/4422102 [00:04<00:00, 1086521.24it/s]
    Extracting data/FashionMNIST/raw/t10k-images-idx3-ubyte.gz to data/FashionMNIST/raw

    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz
    Downloading http://fashion-mnist.s3-website.eu-central-1.amazonaws.com/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz
      0%|          | 0/5148 [00:00<?, ?it/s]    100%|██████████| 5148/5148 [00:00<00:00, 62046772.97it/s]
    Extracting data/FashionMNIST/raw/t10k-labels-idx1-ubyte.gz to data/FashionMNIST/raw





.. GENERATED FROM PYTHON SOURCE LINES 48-59

Tensorclasses are dataclasses that expose dedicated tensor methods over
its contents much like ``TensorDict``. They are a good choice when the
structure of the data you want to store is fixed and predictable.

As well as specifying the contents, we can also encapsulate related
logic as custom methods when defining the class. In this case we’ll
write a ``from_dataset`` classmethod that takes a dataset as input and
creates a tensorclass containing the data from the dataset. We create
memory-mapped tensors to hold the data. This will allow us to
efficiently load batches of transformed data from disk rather than
repeatedly load and transform individual images.

.. GENERATED FROM PYTHON SOURCE LINES 59-81

.. code-block:: Python



    @tensorclass
    class FashionMNISTData:
        images: torch.Tensor
        targets: torch.Tensor

        @classmethod
        def from_dataset(cls, dataset, device=None):
            data = cls(
                images=MemoryMappedTensor.empty(
                    (len(dataset), *dataset[0][0].squeeze().shape), dtype=torch.float32
                ),
                targets=MemoryMappedTensor.empty((len(dataset),), dtype=torch.int64),
                batch_size=[len(dataset)],
                device=device,
            )
            for i, (image, target) in enumerate(dataset):
                data[i] = cls(images=image, targets=torch.tensor(target), batch_size=[])
            return data









.. GENERATED FROM PYTHON SOURCE LINES 82-85

We will create two tensorclasses, one each for the training and test data. Note that
we incur some overhead here as we are looping over the entire dataset, transforming
and saving to disk.

.. GENERATED FROM PYTHON SOURCE LINES 85-89

.. code-block:: Python


    training_data_tc = FashionMNISTData.from_dataset(training_data, device=device)
    test_data_tc = FashionMNISTData.from_dataset(test_data, device=device)








.. GENERATED FROM PYTHON SOURCE LINES 90-101

DataLoaders
----------------

We’ll create DataLoaders from the ``torchvision``-provided Datasets, as
well as from our memory-mapped TensorDicts.

Since ``TensorDict`` implements ``__len__`` and ``__getitem__`` (and
also ``__getitems__``) we can use it like a map-style Dataset and create
a ``DataLoader`` directly from it. Note that because ``TensorDict`` can
already handle batched indices, there is no need for collation, so we
pass the identity function as ``collate_fn``.

.. GENERATED FROM PYTHON SOURCE LINES 101-114

.. code-block:: Python


    batch_size = 64

    train_dataloader = DataLoader(training_data, batch_size=batch_size)  # noqa: TOR401
    test_dataloader = DataLoader(test_data, batch_size=batch_size)  # noqa: TOR401

    train_dataloader_tc = DataLoader(  # noqa: TOR401
        training_data_tc, batch_size=batch_size, collate_fn=lambda x: x
    )
    test_dataloader_tc = DataLoader(  # noqa: TOR401
        test_data_tc, batch_size=batch_size, collate_fn=lambda x: x
    )








.. GENERATED FROM PYTHON SOURCE LINES 115-121

Model
-------

We use the same model from the
`Quickstart Tutorial <https://pytorch.org/tutorials/beginner/basics/quickstart_tutorial.html>`__.


.. GENERATED FROM PYTHON SOURCE LINES 121-145

.. code-block:: Python



    class Net(nn.Module):
        def __init__(self):
            super().__init__()
            self.flatten = nn.Flatten()
            self.linear_relu_stack = nn.Sequential(
                nn.Linear(28 * 28, 512),
                nn.ReLU(),
                nn.Linear(512, 512),
                nn.ReLU(),
                nn.Linear(512, 10),
            )

        def forward(self, x):
            x = self.flatten(x)
            logits = self.linear_relu_stack(x)
            return logits


    model = Net().to(device)
    model_tc = Net().to(device)
    model, model_tc





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (Net(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    ), Net(
      (flatten): Flatten(start_dim=1, end_dim=-1)
      (linear_relu_stack): Sequential(
        (0): Linear(in_features=784, out_features=512, bias=True)
        (1): ReLU()
        (2): Linear(in_features=512, out_features=512, bias=True)
        (3): ReLU()
        (4): Linear(in_features=512, out_features=10, bias=True)
      )
    ))



.. GENERATED FROM PYTHON SOURCE LINES 146-152

Optimizing the parameters
---------------------------------

We'll optimise the parameters of the model using stochastic gradient descent and
cross-entropy loss.


.. GENERATED FROM PYTHON SOURCE LINES 152-177

.. code-block:: Python


    loss_fn = nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)
    optimizer_tc = torch.optim.SGD(model_tc.parameters(), lr=1e-3)


    def train(dataloader, model, loss_fn, optimizer):
        size = len(dataloader.dataset)
        model.train()

        for batch, (X, y) in enumerate(dataloader):
            X, y = X.to(device), y.to(device)

            pred = model(X)
            loss = loss_fn(pred, y)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            if batch % 100 == 0:
                loss, current = loss.item(), batch * len(X)
                print(f"loss: {loss:>7f} [{current:>5d}/{size:>5d}]")









.. GENERATED FROM PYTHON SOURCE LINES 178-182

The training loop for our tensorclass-based DataLoader is very similar, we just
adjust how we unpack the data to the more explicit attribute-based retrieval offered
by the tensorclass. The ``.contiguous()`` method loads the data stored in the memmap
tensor.

.. GENERATED FROM PYTHON SOURCE LINES 182-268

.. code-block:: Python



    def train_tc(dataloader, model, loss_fn, optimizer):
        size = len(dataloader.dataset)
        model.train()

        for batch, data in enumerate(dataloader):
            X, y = data.images.contiguous(), data.targets.contiguous()

            pred = model(X)
            loss = loss_fn(pred, y)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            if batch % 100 == 0:
                loss, current = loss.item(), batch * len(X)
                print(f"loss: {loss:>7f} [{current:>5d}/{size:>5d}]")


    def test(dataloader, model, loss_fn):
        size = len(dataloader.dataset)
        num_batches = len(dataloader)
        model.eval()
        test_loss, correct = 0, 0
        with torch.no_grad():
            for X, y in dataloader:
                X, y = X.to(device), y.to(device)

                pred = model(X)

                test_loss += loss_fn(pred, y).item()
                correct += (pred.argmax(1) == y).type(torch.float).sum().item()

        test_loss /= num_batches
        correct /= size

        print(
            f"Test Error: \n Accuracy: {(100 * correct):>0.1f}%, Avg loss: {test_loss:>8f} \n"
        )


    def test_tc(dataloader, model, loss_fn):
        size = len(dataloader.dataset)
        num_batches = len(dataloader)
        model.eval()
        test_loss, correct = 0, 0
        with torch.no_grad():
            for batch in dataloader:
                X, y = batch.images.contiguous(), batch.targets.contiguous()

                pred = model(X)

                test_loss += loss_fn(pred, y).item()
                correct += (pred.argmax(1) == y).type(torch.float).sum().item()

        test_loss /= num_batches
        correct /= size

        print(
            f"Test Error: \n Accuracy: {(100 * correct):>0.1f}%, Avg loss: {test_loss:>8f} \n"
        )


    for d in train_dataloader_tc:
        print(d)
        break

    import time

    t0 = time.time()
    epochs = 5
    for t in range(epochs):
        print(f"Epoch {t + 1}\n-------------------------")
        train_tc(train_dataloader_tc, model_tc, loss_fn, optimizer_tc)
        test_tc(test_dataloader_tc, model_tc, loss_fn)
    print(f"Tensorclass training done! time: {time.time() - t0: 4.4f} s")

    t0 = time.time()
    epochs = 5
    for t in range(epochs):
        print(f"Epoch {t + 1}\n-------------------------")
        train(train_dataloader, model, loss_fn, optimizer)
        test(test_dataloader, model, loss_fn)
    print(f"Training done! time: {time.time() - t0: 4.4f} s")




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    FashionMNISTData(
        images=Tensor(shape=torch.Size([64, 28, 28]), device=cpu, dtype=torch.float32, is_shared=False),
        targets=Tensor(shape=torch.Size([64]), device=cpu, dtype=torch.int64, is_shared=False),
        batch_size=torch.Size([64]),
        device=cpu,
        is_shared=False)
    Epoch 1
    -------------------------
    loss: 2.316649 [    0/60000]
    loss: 2.304098 [ 6400/60000]
    loss: 2.285238 [12800/60000]
    loss: 2.272552 [19200/60000]
    loss: 2.273343 [25600/60000]
    loss: 2.235441 [32000/60000]
    loss: 2.244488 [38400/60000]
    loss: 2.211945 [44800/60000]
    loss: 2.204993 [51200/60000]
    loss: 2.189702 [57600/60000]
    Test Error: 
     Accuracy: 49.1%, Avg loss: 2.179473 

    Epoch 2
    -------------------------
    loss: 2.188035 [    0/60000]
    loss: 2.180544 [ 6400/60000]
    loss: 2.134132 [12800/60000]
    loss: 2.138141 [19200/60000]
    loss: 2.109451 [25600/60000]
    loss: 2.046054 [32000/60000]
    loss: 2.071310 [38400/60000]
    loss: 2.003033 [44800/60000]
    loss: 1.995590 [51200/60000]
    loss: 1.937634 [57600/60000]
    Test Error: 
     Accuracy: 62.2%, Avg loss: 1.935382 

    Epoch 3
    -------------------------
    loss: 1.963578 [    0/60000]
    loss: 1.939828 [ 6400/60000]
    loss: 1.835823 [12800/60000]
    loss: 1.853752 [19200/60000]
    loss: 1.769263 [25600/60000]
    loss: 1.707910 [32000/60000]
    loss: 1.721687 [38400/60000]
    loss: 1.629753 [44800/60000]
    loss: 1.637764 [51200/60000]
    loss: 1.534096 [57600/60000]
    Test Error: 
     Accuracy: 62.2%, Avg loss: 1.555525 

    Epoch 4
    -------------------------
    loss: 1.616929 [    0/60000]
    loss: 1.587389 [ 6400/60000]
    loss: 1.443615 [12800/60000]
    loss: 1.494276 [19200/60000]
    loss: 1.389540 [25600/60000]
    loss: 1.369903 [32000/60000]
    loss: 1.383821 [38400/60000]
    loss: 1.313691 [44800/60000]
    loss: 1.341438 [51200/60000]
    loss: 1.235367 [57600/60000]
    Test Error: 
     Accuracy: 63.7%, Avg loss: 1.269581 

    Epoch 5
    -------------------------
    loss: 1.343118 [    0/60000]
    loss: 1.329155 [ 6400/60000]
    loss: 1.173306 [12800/60000]
    loss: 1.257524 [19200/60000]
    loss: 1.144073 [25600/60000]
    loss: 1.156701 [32000/60000]
    loss: 1.180798 [38400/60000]
    loss: 1.123880 [44800/60000]
    loss: 1.157492 [51200/60000]
    loss: 1.066630 [57600/60000]
    Test Error: 
     Accuracy: 64.8%, Avg loss: 1.095812 

    Tensorclass training done! time:  8.4077 s
    Epoch 1
    -------------------------
    loss: 2.306571 [    0/60000]
    loss: 2.292312 [ 6400/60000]
    loss: 2.273235 [12800/60000]
    loss: 2.257736 [19200/60000]
    loss: 2.251508 [25600/60000]
    loss: 2.221986 [32000/60000]
    loss: 2.219167 [38400/60000]
    loss: 2.189410 [44800/60000]
    loss: 2.187221 [51200/60000]
    loss: 2.141481 [57600/60000]
    Test Error: 
     Accuracy: 46.9%, Avg loss: 2.146650 

    Epoch 2
    -------------------------
    loss: 2.165177 [    0/60000]
    loss: 2.150629 [ 6400/60000]
    loss: 2.093521 [12800/60000]
    loss: 2.099095 [19200/60000]
    loss: 2.051527 [25600/60000]
    loss: 1.995123 [32000/60000]
    loss: 2.011067 [38400/60000]
    loss: 1.937512 [44800/60000]
    loss: 1.940935 [51200/60000]
    loss: 1.852037 [57600/60000]
    Test Error: 
     Accuracy: 59.6%, Avg loss: 1.866742 

    Epoch 3
    -------------------------
    loss: 1.907126 [    0/60000]
    loss: 1.872874 [ 6400/60000]
    loss: 1.760788 [12800/60000]
    loss: 1.790521 [19200/60000]
    loss: 1.677774 [25600/60000]
    loss: 1.646987 [32000/60000]
    loss: 1.651601 [38400/60000]
    loss: 1.568368 [44800/60000]
    loss: 1.585540 [51200/60000]
    loss: 1.470971 [57600/60000]
    Test Error: 
     Accuracy: 61.4%, Avg loss: 1.501027 

    Epoch 4
    -------------------------
    loss: 1.573118 [    0/60000]
    loss: 1.536599 [ 6400/60000]
    loss: 1.393158 [12800/60000]
    loss: 1.455690 [19200/60000]
    loss: 1.332036 [25600/60000]
    loss: 1.348543 [32000/60000]
    loss: 1.351916 [38400/60000]
    loss: 1.289196 [44800/60000]
    loss: 1.307499 [51200/60000]
    loss: 1.212335 [57600/60000]
    Test Error: 
     Accuracy: 63.6%, Avg loss: 1.240584 

    Epoch 5
    -------------------------
    loss: 1.318444 [    0/60000]
    loss: 1.300594 [ 6400/60000]
    loss: 1.140585 [12800/60000]
    loss: 1.241945 [19200/60000]
    loss: 1.107841 [25600/60000]
    loss: 1.152181 [32000/60000]
    loss: 1.169994 [38400/60000]
    loss: 1.115589 [44800/60000]
    loss: 1.132451 [51200/60000]
    loss: 1.059282 [57600/60000]
    Test Error: 
     Accuracy: 64.8%, Avg loss: 1.080112 

    Training done! time:  33.2435 s





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 59.585 seconds)


.. _sphx_glr_download_tutorials_tensorclass_fashion.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: tensorclass_fashion.ipynb <tensorclass_fashion.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: tensorclass_fashion.py <tensorclass_fashion.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
